buildscript {
  ext {
    springBootVersion = '1.5.8.RELEASE'
  }
  repositories {
    mavenCentral()
    maven { url "http://jcenter.bintray.com" }
    maven { url "https://plugins.gradle.org/m2/" }
  }
  dependencies {
    classpath 'com.github.ben-manes:gradle-versions-plugin:0.15.0'
    classpath 'gradle.plugin.com.gorylenko.gradle-git-properties:gradle-git-properties:1.4.17'
    classpath("net.saliman:gradle-cobertura-plugin:2.5.0")
    classpath("nu.studer:gradle-credentials-plugin:${gradleCredentialsVersion}")
    classpath("org.jfrog.buildinfo:build-info-extractor-gradle:${buildExtractorVersion}")
    classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
  }
}

plugins {
  id 'com.adarshr.test-logger' version '1.1.2'
}

defaultTasks 'clean', 'build'

version = "${version}"
group = "${group}"

//--------------------------------------------------------------------------
// Use this task to see dependency updates available:
//--------------------------------------------------------------------------
// ./gradlew dependencyUpdates -Drevision=release
//--------------------------------------------------------------------------

apply plugin: 'base'
apply plugin: 'com.gorylenko.gradle-git-properties'
apply plugin: 'com.github.ben-manes.versions'
apply plugin: 'groovy'
apply plugin: 'idea'
apply plugin: 'maven'
apply plugin: 'net.saliman.cobertura'
apply plugin: 'nu.studer.credentials'
apply plugin: 'org.springframework.boot'

repositories {
  mavenLocal()
  mavenCentral()
}

ext {
  springCloudVersion = 'Dalston.SR4'
}

dependencies {
  compile("com.google.guava:guava:20.0")
  compile("com.netflix.hollow:hollow:${hollowVersion}")
  compile("com.netflix.hollow:hollow-diff-ui:${hollowVersion}")
  compile("com.netflix.hollow:hollow-explorer-ui:${hollowVersion}")
  compile("commons-beanutils:commons-beanutils:1.7.0")
  compile("io.prometheus:simpleclient:${prometheusSimpleClientVersion}")
  compile("io.prometheus:simpleclient_common:${prometheusSimpleClientVersion}")
  compile("io.prometheus:simpleclient_hotspot:${prometheusSimpleClientVersion}")
  compile("io.prometheus:simpleclient_servlet:${prometheusSimpleClientVersion}")
  compile("io.prometheus:simpleclient_spring_boot:${prometheusSimpleClientVersion}")
  compile("net.rakugakibox.springbootext:spring-boot-ext-logback-access:1.6")
  compile("org.codehaus.gpars:gpars:1.2.1")
  compile("org.codehaus.groovy:groovy-all:${groovyVersion}")

  compile("org.springframework.boot:spring-boot-starter-actuator:${springBootVersion}")
//  compile("org.springframework.boot:spring-boot-starter-security:${springBootVersion}")
  compile("org.springframework.boot:spring-boot-starter-web:${springBootVersion}")

  testRuntime("cglib:cglib-nodep:${cglibVersion}")

  testCompile('org.awaitility:awaitility-groovy:3.0.0')
  testCompile("org.spockframework:spock-core:${spockVersion}")
  testCompile("org.spockframework:spock-spring:${spockVersion}")
  testCompile('org.springframework.boot:spring-boot-starter-test')
}

dependencyManagement {
  imports {
    mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
  }
}

test {
  // support passing -Dsystem.property=value to this task (such as -Dspring.profiles.active=ci)
  systemProperties = System.properties
  testLogging {
    exceptionFormat 'full'
  }
  afterSuite { desc, result ->
    if (!desc.parent) {
      print "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
    }
  }
}

bootRun {
  // support passing -Dsystem.property=value to this task (such as -Dspring.profiles.active=stage)
  systemProperties = System.properties
}

cobertura {
  coverageReportDir = new File('cobertura/')
  coverageFormats = ['html', 'xml']
  coverageExcludes = ['.*AccountApplication.*', 'com.os.accounts.domain.generated.*']
  coverageIgnoreTrivial = true
  coverageCheckLineRate = 100
  coverageCheckTotalLineRate = 100
  coverageCheckHaltOnFailure = true
}

processResources {
  filesMatching("**/application.yml") {
    expand([
        version: project.version,
        date   : new Date(),
    ])
  }
}

idea {
  module {
    excludeDirs = []
    ['.gradle', 'gradle/wrapper', 'logs', 'out', 'build'].each {
      excludeDirs << file(it)
    }
  }
}

task copyJar(type: Copy) {
  dependsOn build
  from "build/libs/${project.name}-${project.version}.jar"
  into 'docker'
  rename { String fileName ->
    fileName.replace("-${project.version}", "").replace("${project.name}", "app")
  }
}

configurations.all { exclude group: 'org.slf4j', module: 'slf4j-log4j12' }

gitProperties {
  gitPropertiesDir = new File("${project.rootDir}/src/main/resources")
}

task generateHollowConsumerApi(type: JavaExec) {
  classpath = sourceSets.main.runtimeClasspath
  main = 'com.os.accounts.hollow.AccountHollowAPIGenerator'
  args("com.os.accounts.domain.Account", "com.os.accounts.domain.generated")
}

// This forces the source code generation to happen every time we build.
build.finalizedBy(copyJar, generateHollowConsumerApi)